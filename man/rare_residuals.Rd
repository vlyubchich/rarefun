% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rare_residuals.R
\name{rare_residuals}
\alias{rare_residuals}
\title{Detect Rare Events and Seasonality Shifts in Time Series Residuals}
\usage{
rare_residuals(
  x,
  seasonal = FALSE,
  period = NULL,
  method = "all",
  fourier_terms = 2,
  seasonality_shift = seasonal,
  stl_args = list(s.window = 7, robust = TRUE),
  iforest_args = list(),
  dbscan_args = list()
)
}
\arguments{
\item{x}{A numeric vector (time series values), a univariate `ts` object, or
a data frame with columns `time` (numeric or Date) and `value` (numeric).
If a vector, assumes regular time steps starting from 1. If a `ts` is
provided, the time index is derived via `stats::time(x)`.}

\item{seasonal}{Logical, indicating if the time series is seasonal (TRUE) or
non-seasonal (FALSE) (default: FALSE). If `x` is a univariate `ts` object with
`frequency(x) > 1`, the function will automatically treat the series as
seasonal (i.e., set `seasonal = TRUE`).}

\item{period}{Numeric, the period of seasonality, e.g., 12 for monthly or 365.25
for daily data (default: NULL). If NULL and `seasonal == TRUE`, the period is
automatically determined. For `ts` input, `frequency(x)` is used; otherwise, it is
estimated using spectral analysis.}

\item{method}{Character, specifying the anomaly detection method: "iforest",
"dbscan", or "all" (default: "all").}

\item{fourier_terms}{Integer, number of Fourier term pairs for seasonal modeling
in Fourier smoothing (default: 2).}

\item{seasonality_shift}{Logical, whether to compute seasonality shift (e.g., early
spring) by comparing STL and Fourier seasonal components (default: TRUE if
`seasonal = TRUE`).}

\item{stl_args}{A named list of arguments passed to `stats::stl()` for detrending and
deseasonalizing `x`. Default: `list(s.window = 7, robust = TRUE)`.}

\item{iforest_args}{A named list of arguments passed to `rare_iforest()` (e.g.,
`list(ntrees = 200)`). Default: `list()`.}

\item{dbscan_args}{A named list of arguments passed to `rare_dbscan()` (e.g.,
`list(minPts = 10)`). Default: `list()`.}
}
\value{
A list containing:
  \itemize{
    \item \code{data}: A data frame with:
      \itemize{
        \item \code{time}: Input time points.
        \item \code{value}: Original time series values.
        \item \code{year}: Year extracted from time.
        \item \code{residual}: Residuals from STL (seasonal) or LOESS (non-seasonal) smoothing.
        \item \code{residual_fourier}: Residuals from Fourier smoothing (if `seasonal = TRUE`).
        \item \code{is_anomaly_iforest}: Logical, anomalies from Isolation Forest (if applicable).
        \item \code{is_anomaly_dbscan}: Logical, anomalies from DBSCAN (if applicable).
        \item \code{score_iforest}: Anomaly scores from Isolation Forest.
        \item \code{score_dbscan}: Anomaly scores from DBSCAN.
      }
    \item \code{seasonality_shift}: A list (if `seasonality_shift = TRUE` and
      `seasonal = TRUE`) with:
      \itemize{
        \item \code{lag}: Estimated time shift (positive if STL peaks
          earlier than Fourier, e.g., early spring).
        \item \code{stl_seasonal}: Seasonal component from STL.
        \item \code{fourier_seasonal}: Seasonal component from Fourier.
      }
  }
}
\description{
This function filters a time series to compute residuals using STL decomposition
(for seasonal data) or LOESS smoothing (for non-seasonal data) and identifies
rare events (anomalies) in the residuals using Isolation Forest or DBSCAN. For
seasonal time series, it applies STL decomposition and full-length Fourier
smoothing separately, comparing their seasonality estimates to detect shifts
(e.g., early spring) by analyzing differences in seasonal peaks.
}
\details{
For non-seasonal data, residuals are computed using LOESS with `year` as the
predictor. For seasonal data, residuals are computed twice: (1) using STL
decomposition to extract the remainder component, and (2) using a full-length
Fourier series to capture fixed periodicity. The STL seasonal component is
smoothed using the `s.window` parameter (numeric for flexible smoothing, "periodic"
for fixed seasonality) and further smoothed with LOESS for shift detection.
Seasonality shifts are detected by comparing smoothed STL and Fourier seasonal
components via cross-correlation to estimate the lag (in days) where peaks differ
(e.g., early spring). Rare events are detected in STL (or LOESS for non-seasonal)
residuals using `rare_iforest` or `rare_dbscan`. The period is estimated via
spectral analysis if not provided. Input validation prevents coercion errors.
Separate argument lists (`stl_args`, `iforest_args`, `dbscan_args`) ensure
function-specific parameters are passed correctly.

If `x` is a univariate `ts` object with `frequency(x) > 1`, the function will
automatically treat the series as seasonal (i.e., set `seasonal = TRUE`). When
`period` is not provided, `frequency(x)` will be used.
}
\examples{
\dontrun{
# Seasonal time series with Date index
set.seed(123)
dates <- seq(as.Date("2020-01-01"), by = "day", length.out = 1500)
value <- sin(2 * pi * seq_along(dates) / 365.25) + rnorm(1500, 0, 0.2)
x <- data.frame(time = dates, value = value)
result <- rare_residuals(x, seasonal = TRUE, period = 365.25, method = "all",
iforest_args = list(ntrees = 100))
plot(result$data$time, result$data$value, type = "l", main = "Time Series")
points(result$data$time[result$data$is_anomaly_iforest],
       result$data$value[result$data$is_anomaly_iforest], col = "red", pch = 19)
cat("Seasonality shift:", result$seasonality_shift$lag, "\n")

# Plot seasonal components
plot(result$data$time, result$seasonality_shift$stl_seasonal, type = "l",
     col = "blue", main = "Seasonal Components")
lines(result$data$time, result$seasonality_shift$fourier_seasonal, col = "red")
legend("topright", c("STL", "Fourier"), col = c("blue", "red"), lty = 1)

# Classic data example (ts input)
result_AirPassengers <- rare_residuals(AirPassengers,
                                      method = "iforest",
                                      iforest_args = list(ntrees = 100,
                                                          threshold = 0.6))
# View results
ggplot2::ggplot(result_AirPassengers$data, aes(x = time, y = value)) +
   geom_line(color = "gray") +
   geom_point(aes(color = is_anomaly_iforest)) +
   labs(title = "Anomaly detection in AirPassengers using isolation forest",
        x = "Time",
        y = "Number of passengers",
        color = "Anomaly status") +
   scale_color_manual(values = c("gray", "red"), labels = c("Normal", "Anomaly")) +
   theme_minimal()
}
}
